We can now move onto the spatial analysis component of this study. Highly multiplexed imaging technologies measure the spatial distributions of molecule abundances across tissue sections. As such, having an option to analyze single cells in their spatial tissue context is a key strength of these technologies.
Here, we will make use of `imcRtools` to conduct the spatial analysis.

```{r, load_libraries, echo = TRUE, eval = TRUE, message = FALSE, warning = FALSE}

# Load libraries
library(imcRtools)
library(cytomapper)
library(RColorBrewer)
library(tidyverse)
library(dplyr)
library(scater)
library(ggplot2)
library(ggpubr)
library(viridis)
library(cowplot)
library(patchwork)
library(corrplot)
library(Hmisc)
library(scales)
library(pheatmap)
```

We will need to read in the processed and cell-typed `spatialExperiment` object. We will once again be adding slots and components to the object through the spatial analysis. 

```{r, read_Spe, echo = TRUE, eval = TRUE, message = FALSE, warning = FALSE}

# Read in the spatial experiment object
spe <- readRDS("../../Data/002_Processed/CellTyped_singleCell_Analysis_Spe.Rds")

```

Many spatial analysis approaches either compare the observed versus expected number of cells around a given cell type (point process) or utilize interaction graphs (spatial object graphs) to estimate clustering or interaction frequencies between cell types.
The `steinbock` framework allows the construction of these spatial graphs. During image processing, we have constructed a spatial graph by expanding the individual cell masks by 4 pixels.
The `imcRtools` package further allows the ad hoc contruction of spatial graphs directly using a `SpatialExperiment` or `SingleCellExperiment` object while considering the spatial location (centroids) or individual cells. The `buildSpatialGraph` function allows constructing spatial graphs by detecting the k-nearest neighbors in 2D (`knn`), by detecting all cells within a given distance to the center cell (`expansion`) and by Delaunay triangularion (`delaunay`).
When constructing a knn graph, the number of neighbors (`k`) needs to be set and (optionally) the maximum distance to consider (`max_dist`) can be specified. When constructing a graph via expansion, the distance to expand (`threshold`) needs to be provided. For graphs constructed via Delaunay triangulation, the `max_dist` parameter can be set to avoid unusually large connections at the edge of the image. 
In the block below, we will construct a KNN graph with 20 nearest neighbors. We will use this graph downstream when we do the neighborhood analysis. 

```{r, generate_KNN_Interaction_Graph, echo = TRUE, eval = TRUE, message = FALSE, warning = FALSE}

# Construct a KNN spatial interaction graph with 20 nearest neighbors
spe <- buildSpatialGraph(spe, 
                         img_id = "sample_id",
                         type = "knn",
                         k = 20)

```

The first analysis we will run is an interaction / avoidance analysis. This analysis will focus on statistically testing the pairwise interaction between all cell types of the dataset. For this, `imcRtools` provides the `testInteractions` function which implements the interaction testing strategy proposed by Schapiro et al. 2017 here: https://www.nature.com/articles/nmeth.4391

Per grouping level (e.g., image), the `testInteractions` function computes the averaged cell type/cell type interaction count and compares this count against an empirical null distribution which is generated by permuting all cell labels (while maintaining the tissue structure). Below, we will use the `strinbock` generated spatial interaction graph and estimate the interaction or avoidance between cell types in the dataset. 
The returned `DataFrame` contains the test results per grouping level (in this case the sample_id, `group_by`), "from" cell type (`from_label`) and "to" cell type (`to_label`). The `sigval` entry indicates if a pair of cell types is significantly interacting (`sigval = 1`), or if a pair of cell types is significantly avoiding (`sigval = -1`) of if no significant interaction or avoidance was detected (`sigval = 0`). These results can be visualized by computing the sum of the `sigval` entries across all images. 

```{r, interaction_analysis, echo = TRUE, eval = TRUE, message = FALSE, warning = FALSE}

# Set seed
set.seed(03061999)

# Run the testInteractions function
out <- testInteractions(spe, 
                        group_by = "sample_id",
                        label = "cellTypes", 
                        colPairName = "neighborhood")

# Visualize the results by computing the sum of all sigval entries across ROIs
out %>% as_tibble() %>%
  group_by(from_label, to_label) %>%
  summarise(sum_sigval = sum(sigval, na.rm = TRUE)) %>%
  ggplot() +
  geom_tile(aes(from_label, to_label, fill = sum_sigval, label = sum_sigval)) +
  geom_text(aes(from_label, to_label, label = sum_sigval)) +
  scale_fill_gradient2(low = muted("blue"), mid = "white", high = muted("red")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y = "",
       x = "",
       fill = "Interaction \n Score")
```

Next, we will begin the neighborhood analysis. In the following code chunk, we will use the 20-nearest neighbor graph as constructed above to define the direct cellular neighborhood. The `aggregateNeighbors` function allows neighborhood aggregation in 2 different ways:

1.) For each cell the function computes the fraction of cells of a certain cell type (e.g., cell type) among its neighbors.

2.) For each cell, it aggregates (e.g., mean) the expression counts acros all neighboring cells. 

Based on these measures, cells can now be clustered into cellular neighborhoods. For our analysis, we will use method #1

```{r, neighborhood_analysis, echo = TRUE, eval = TRUE, message = FALSE, warning = FALSE}

# Aggregate neighbors
spe <- aggregateNeighbors(spe, 
                          colPairName = "knn_interaction_graph", 
                          aggregate_by = "metadata", 
                          count_by = "cellTypes")


# Set a seed
set.seed(03061999)

# Cluster cells into cellular neighborhoods
cn_1 <- kmeans(spe$aggregatedNeighbors, centers = 6)
spe$cn_celltypes <- as.factor(cn_1$cluster)

# Plot the cell neighborhoods
plotSpatial(spe, 
            node_color_by = "cn_celltypes", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
  scale_color_brewer(palette = "Paired")


```

We can verify the identity of each cellular neighborhood by plotting them in the form of a column scaled heatmap.

```{r, CN_heatmap, echo = TRUE, eval = TRUE, warning = FALSE, message = FALSE}

# Verify the identity of each neighborhood
for_plot <- table(as.character(spe$cn_celltypes), spe$cellTypes)
pheatmap(for_plot, 
         color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         scale = "column")

# Re-code the cellular neighborhoods
spe$cn_celltypes <- ifelse(spe$cn_celltypes == 1, "Undefined Enriched",
                           ifelse(spe$cn_celltypes == 2, "Proliferative Epithelia Enriched",
                                  ifelse(spe$cn_celltypes == 3, "Immune Enriched",
                                         ifelse(spe$cn_celltypes == 4, "Stroma Enriched",
                                                ifelse(spe$cn_celltypes == 5, "Cytotoxic Enriched", "Epithelia Enriched")))))
```

Now that we have defined our cellular neighborhod, we can run statistical testing to see each celltypes status in the neighborhood. 
We achieve this by running a hypergeometric test comparing the cell type-neighborhood preference with a random distribution of the cell type across neighborhoods, adjusted using the Benjamini-Hochberg method.

```{r, hypergeometric_test, echo = TRUE, eval = TRUE, warning = FALSE, message = FALSE}

# Save clustering results as a dataframe
for_plot <- as.data.frame(table(spe$cn_celltypes, spe$cellTypes))

# Aggregate total counts of each cell type across all neighborhoods
total_cell_type_counts <- for_plot %>%
  group_by(Var2) %>%
  summarise(Count = sum(Freq))

# Total number of cells in the dataset
total_cells <- sum(total_cell_type_counts$Count)

# Initialize a results dataframe for the hypergeometric test
results <- data.frame()

# Run hypergeometric test to test for significance
for (cell_type in unique(for_plot$Var2)) {
  for (neighborhood in unique(for_plot$Var1)) {
    
    # Number of this cell type in the current neighborhood
    m <- for_plot %>% 
      filter(Var2 == cell_type & Var1 == neighborhood) %>% 
      pull(Freq)
    
    # Total number of this cell type across all neighborhoods
    k <- total_cell_type_counts %>% 
      filter(Var2 == cell_type) %>% 
      pull(Count)
    
    # Total number of cells in the current neighborhood
    n <- sum(for_plot %>% filter(Var1 == neighborhood) %>% pull(Freq))
    
    # Total number of cells across all neighborhoods
    N <- total_cells
    
    # Hypergeometric test
    p_value <- phyper(m - 1, k, N - k, n, lower.tail = FALSE)
    
    # Store results
    results <- rbind(results, data.frame(CellType = cell_type,
                                         Neighborhood = neighborhood,
                                         PValue = p_value))
  }
}

# Adjust p-values using Benjamini-Hochberg
results <- results %>%
  mutate(AdjPValue = p.adjust(PValue, method = "BH"))

# Assign stars to indicate signifiance
results$Stars <- ifelse(results$AdjPValue == 0, "***",
                        ifelse(results$AdjPValue < 0.01, "**",
                               ifelse(results$AdjPValue < 0.05, "*", "")))

# Plot heatmap with labels
for_plot <- table(as.character(spe$cn_celltypes), spe$cellTypes)
pheatmap(for_plot, 
         color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         scale = "column",
         name = "Z-Score",
         show_row_names = TRUE,
         show_column_names = TRUE,
         angle_col = 45)
```

We can now make some pretty graphics such as the percentage of each cellular neighborhood split by early and late

```{r, CN_Pies, echo = TRUE, eval = TRUE, message = FALSE, warning = FALSE}

# Split the spe object into early and late
eo <- spe[,spe$Indication == "EOCRC"]
lo <- spe[,spe$Indication == "LOCRC"]

# Convert spe to a dataframe
spe.df <- as.data.frame(colData(spe))
eo.df <- as.data.frame(colData(eo))

# Summarize the proportions
CNprops <- spe.df %>%
  group_by(Indication, cn_celltypes) %>%
  summarise(count = n()) %>%
  mutate(Proportion = count / sum(count))
CNprops$Percent <- round(CNprops$Proportion*100, 2)
CNprops$Percent <- paste(CNprops$Percent, "%", sep = "")

# Split CNprops into early and late
ggplot(CNprops, aes(x  = 2 , y = Proportion, fill = cn_celltypes)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = Percent), position = position_stack(vjust = 0.5)) +
  coord_polar("y") +
  xlim(0.5, 2.5) +
  facet_wrap(~Indication) +
  scale_fill_manual(values = brewer.pal(6, "Paired")) +
  labs(x = "",
       y = "",
       fill = "") +
  theme_void() +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        strip.text = element_text(face = "bold", size = 20),
        legend.position = "bottom")
```


