# The purpose of this script is to conduct a spatial analysis on the early / late
# onset imaging mass cytometry samples. 
# A copy of this code is available on github 
# https://github.com/micmartinez99/Early_Onset_IMC

# To get this code onto your computer, simply clone the repository to your machine.
# You will have to go through and modify all the file paths. 

# Clear the environment
rm(list = ls())

# Load libraries
library(imcRtools)
library(cytomapper)
library(RColorBrewer)
library(tidyverse)
library(dplyr)
library(scater)
library(ggplot2)
library(ggpubr)
library(viridis)
library(cowplot)
library(patchwork)
library(corrplot)
library(Hmisc)
library(scales)
library(pheatmap)

library(agridat)
library(ghibli)
library(ggdist)

# Initialize a function to generate subdirectories
newDir <- function(x) {
  if (!dir.exists(x)) {
    dir.create(x)
  }
}

# Create an output directory
opDir <- newDir("Outputs/003_Spatial_Assessment/")
dataDir <- newDir("Data/003_Spatial")

# Read in the processed spe object
spe <- readRDS("Data/002_Processed/CellTyped_singleCell_Analysis_Spe.Rds")

# Read in the images and masks
img <- readRDS("Data/Images/Normalized_Final_Image_Dataset.Rds")
masks <- readRDS("Data/Images/Final_Mask_Dataset.Rds")

################################################################################

#----- Pairwise Interaction / Avoidance analysis

# Per grouping level (e.g., ROI), the testInteractions function computes the 
# averged cell type / cell type interaction count and compares this count
# against an empirical null distribution which is generated by permuting all 
# cell labels (while maintaining the tissue structure).
# The returned dataframe contains the test results per grouping level (in our
# case, ROI), "from" cell type (from_label) and "to" cell type (to_label). The
# sigval entry indicates if a pair of cell types is significantly interacting
# (sigval = 1) or if a pair of cell types is significantly avoiding 
# (sigval = -1) or if no significant interaction or avoidance was detected 
# (sigval = 0).


# Set seed
set.seed(03061999)

# Run the testInteractions function
out <- testInteractions(spe, 
                        group_by = "sample_id",
                        label = "cellTypes", 
                        colPairName = "neighborhood")

# Visualize the results by computing the sum of all sigval entries across ROIs
interactionPlot <- out %>% as_tibble() %>%
  group_by(from_label, to_label) %>%
  summarise(sum_sigval = sum(sigval, na.rm = TRUE)) %>%
  ggplot() +
  geom_tile(aes(from_label, to_label, fill = sum_sigval, label = sum_sigval)) +
  geom_text(aes(from_label, to_label, label = sum_sigval)) +
  scale_fill_gradient2(low = muted("blue"), mid = "white", high = muted("red")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y = "",
       x = "",
       fill = "Interaction \n Score")
ggsave("Outputs/003_Spatial_Assessment/Interaction_Avoidance_Plot.png", interactionPlot, width = 14, height = 10)

#----- Pairwise Interaction / avoidance analysis based on patch

# The imcRtools package further implements an interaction testing strategy
# where the hypothesis is tested that if at least n cells of a certain type are 
# located around a target cell tye (from_cell). This type of testing can be
# performed by selecting method = "patch" abd specifiying the number of 
# patch cells via the patch_size parameter.

# Set seed
set.seed(03061999)

# Run the testInteractions function with method = path
out2 <- testInteractions(spe,
                         group_by = "sample_id",
                         label = "cellTypes",
                         colPairName = "neighborhood",
                         method = "patch",
                         patch_size = 3)

# Visualize the results, you will notice this one will lack symmetry because
patchIntPlot <- out2 %>% as_tibble() %>%
  group_by(from_label, to_label) %>%
  summarise(sum_sigval = sum(sigval, na.rm = TRUE)) %>%
  ggplot() +
  geom_tile(aes(from_label, to_label, fill = sum_sigval, label = sum_sigval)) +
  geom_text(aes(from_label, to_label, label = sum_sigval)) +
  scale_fill_gradient2(low = muted("blue"), mid = "white", high = muted("red")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y = "",
       x = "",
       fill = "Interaction \n Score")
ggsave("Outputs/003_Spatial_Assessment/Pathced_Interaction_Avoidance_Plot.png", patchIntPlot, width = 14, height = 10)

################################################################################

#----- Neighborhood analysis

# The aggregateNeighbors function allows neighborhood aggregation in two 
# different ways. 1.) For each cell, the function computes the fraction of cells
# of a certain cell type (e.g., cell type), among its neighbors.
# 2.) For each cell it aggregates (e.g., mean) the expression counts across all
# neighboring cells.
# We will use method 2 to find neighbors.
# Essentially, find the mean expression value across all neighbors.
# Based on these measures, cells can then be clustered into cellular 
# neighborhoods using kmeans. 

# Construct a KNN spatial interaction graph with 20 nearest neighbors
spe <- buildSpatialGraph(spe, 
                         img_id = "sample_id",
                         type = "knn",
                         k = 20)


# Set a seed
set.seed(03061999)

# Cluster cells into cellular neighborhoods
cn_1 <- kmeans(spe$aggregatedNeighbors, centers = 6)
spe$cn_celltypes <- as.factor(cn_1$cluster)

# Plot the cell neighborhoods
plotSpatial(spe, 
            node_color_by = "cn_celltypes", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
  scale_color_brewer(palette = "Paired")

# Verify the identity of each neighborhood
for_plot <- table(as.character(spe$cn_celltypes), spe$cellTypes)
pheatmap(for_plot, 
         color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         scale = "column")

# Re-code the cellular neighborhoods
spe$cn_celltypes <- ifelse(spe$cn_celltypes == 1, "Undefined Enriched",
                           ifelse(spe$cn_celltypes == 2, "Proliferative Epithelia Enriched",
                                  ifelse(spe$cn_celltypes == 3, "Immune Enriched",
                                         ifelse(spe$cn_celltypes == 4, "Stroma Enriched",
                                                ifelse(spe$cn_celltypes == 5, "Cytotoxic Enriched", "Epithelia Enriched")))))

# Save clustering results as a dataframe
for_plot <- as.data.frame(table(spe$cn_celltypes, spe$cellTypes))

# Aggregate total counts of each cell type across all neighborhoods
total_cell_type_counts <- for_plot %>%
  group_by(Var2) %>%
  summarise(Count = sum(Freq))

# Total number of cells in the dataset
total_cells <- sum(total_cell_type_counts$Count)

# Initialize a results dataframe for the hypergeometric test
results <- data.frame()

# Run hypergeometric test to test for significance
for (cell_type in unique(for_plot$Var2)) {
  for (neighborhood in unique(for_plot$Var1)) {
    
    # Number of this cell type in the current neighborhood
    m <- for_plot %>% 
      filter(Var2 == cell_type & Var1 == neighborhood) %>% 
      pull(Freq)
    
    # Total number of this cell type across all neighborhoods
    k <- total_cell_type_counts %>% 
      filter(Var2 == cell_type) %>% 
      pull(Count)
    
    # Total number of cells in the current neighborhood
    n <- sum(for_plot %>% filter(Var1 == neighborhood) %>% pull(Freq))
    
    # Total number of cells across all neighborhoods
    N <- total_cells
    
    # Hypergeometric test
    p_value <- phyper(m - 1, k, N - k, n, lower.tail = FALSE)
    
    # Store results
    results <- rbind(results, data.frame(CellType = cell_type,
                                         Neighborhood = neighborhood,
                                         PValue = p_value))
  }
}

# Adjust p-values using Benjamini-Hochberg
results <- results %>%
  mutate(AdjPValue = p.adjust(PValue, method = "BH"))

# Assign stars to indicate signifiance
results$Stars <- ifelse(results$AdjPValue == 0, "***",
                        ifelse(results$AdjPValue < 0.01, "**",
                               ifelse(results$AdjPValue < 0.05, "*", "")))

# Save hypergeometric test results as a csv
write.csv(results, file = "Outputs/003_Spatial_Assessment/Cluster_Neighborhood_Hypergeometric_Test_Results.csv")

# Plot heatmap with labels
for_plot <- table(as.character(spe$cn_celltypes), spe$cellTypes)
CN_HM <- pheatmap(for_plot, 
         color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         scale = "column",
         name = "Z-Score",
         show_row_names = TRUE,
         show_column_names = TRUE,
         angle_col = 45)
ggsave("Outputs/003_Spatial_Assessment/Cellular_Neighborhood_Heatmap.png", CN_HM, width = 10, height = 8)

#----- Calculate the percentage of each neighborhood between early and late

# Split the spe object into early and late
eo <- spe[,spe$Indication == "EOCRC"]
lo <- spe[,spe$Indication == "LOCRC"]

# Convert spe to a dataframe
spe.df <- as.data.frame(colData(spe))
eo.df <- as.data.frame(colData(eo))

# Summarize the proportions
CNprops <- spe.df %>%
  group_by(Indication, cn_celltypes) %>%
  summarise(count = n()) %>%
  mutate(Proportion = count / sum(count))
CNprops$Percent <- round(CNprops$Proportion*100, 2)
CNprops$Percent <- paste(CNprops$Percent, "%", sep = "")

# Split CNprops into early and late
CN_pie <- ggplot(CNprops, aes(x  = 2 , y = Proportion, fill = cn_celltypes)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = Percent), position = position_stack(vjust = 0.5)) +
  coord_polar("y") +
  xlim(0.5, 2.5) +
  facet_wrap(~Indication) +
  scale_fill_manual(values = brewer.pal(6, "Paired")) +
  labs(x = "",
       y = "",
       fill = "") +
  theme_void() +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        strip.text = element_text(face = "bold", size = 20),
        legend.position = "bottom")
ggsave("Outputs/003_Spatial_Assessment/CN_Pie_Percentages.png", CN_pie, width = 10, height = 10)


# Summarize the proportions by stage
CNpropsStage <- eo.df %>%
  group_by(Stage, cn_celltypes) %>%
  summarise(count = n()) %>%
  mutate(Proportion = count / sum(count))
CNpropsStage$Percent <- round(CNpropsStage$Proportion*100, 2)
CNpropsStage$Percent <- paste(CNpropsStage$Percent, "%", sep = "")

# Plot by stage
ggplot(CNpropsStage, aes(x  = 2 , y = Proportion, fill = cn_celltypes)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = Percent), position = position_stack(vjust = 0.5)) +
  coord_polar("y") +
  xlim(0.5, 2.5) +
  facet_wrap(~Stage) +
  scale_fill_manual(values = brewer.pal(6, "Paired")) +
  labs(x = "",
       y = "",
       fill = "") +
  theme_void() +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        strip.text = element_text(face = "bold", size = 20),
        legend.position = "bottom")
  
################################################################################

#----- Patch analysis

# The purpose of this analysis is to detect spatial compartments in a supervised
# fashion. The patchDetection function allows the detection of connected sets of
# similar cells.
# Here, this function was used to detect non-tumor (stromal) patches in three 
# steps.
# 1.) Find connected sets of stromal cells using the Steinbock graph
# 2.) Components which contain less than 10 cells are excluded
# 3.) Expand the components by 1 um to construct a concave hull around the 
# patch and include cells within the patch. 

# Create compartment designations for the celltypes
epiCellTypes <- c("Epithelium", "Proliferating Epithelium", "IELs")

# Add the compartment information to the spe object
spe$Compartment <- ifelse(spe$cellTypes %in% epiCellTypes, "Tumor", "NonTumor")

# Detect non-tumor patches
spe <- patchDetection(spe, 
                      patch_cells = spe$Compartment == "NonTumor",
                      img_id = "sample_id",
                      expand_by = 1,
                      min_patch_size = 10,
                      colPairName = "neighborhood")

# Save the non tumor patches to a new coldata entry
spe$nonTumor_patches <- spe$patch_id
spe$patch_id <- NULL

# Visualize distribution of patch sizes (non tumor)
nonTumor_patch_size <- patchSize(spe, "nonTumor_patches")
nonTumor_patch_size <- merge(nonTumor_patch_size, 
                             colData(spe)[match(nonTumor_patch_size$nonTumor_patches, spe$nonTumor_patches),], 
                             by = "nonTumor_patches")

# Plot
sizePlotNT <- ggplot(as.data.frame(nonTumor_patch_size), aes(x = Indication, y = log10(size), fill = Indication)) + 
  geom_boxplot(alpha = 0.3) +
  geom_jitter(aes(color = sample_id), 
              width = 0.1) +
  theme_classic() +
  labs(y = "Log10 Non-Tumor Patch Size",
       x = "",
       fill = "",
       color = "ROI") +
  theme(axis.text.x = element_text(face = "bold", size = 24),
        axis.title.y = element_text(face = "bold", size = 24),
        legend.title = element_text(face = "bold")) +
  guides(fill = "none") +
  stat_compare_means(method = "t.test", 
                     method.args = list(var.equal = FALSE))
ggsave("Outputs/003_Spatial_Assessment/Distributions_NonTumorPatch_Sizes.tiff", sizePlotNT, width = 8, height = 8, dpi = 300)

#----- Visualization of stromal patches on ROIs

# Create a designator for image plotting
spe$ID <- paste(gsub("_", " ", spe$sample_id), spe$Indication, sep = " ")

# Visualize the non tumor patches
nonTumor <- plotSpatial(spe, 
                        node_color_by = "nonTumor_patches", 
                        img_id = "ID", 
                        node_size_fix = 0.5) +
  theme_void() +
  theme(legend.position = "none",
        strip.text = element_text(face = "bold", size = 18),
        axis.text.y = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks = element_blank()) +
  labs(x = "",
       y = "") +
  scale_color_manual(values = rev(colors()))
ggsave("Outputs/003_Spatial_Assessment/NT_Patches.tiff", nonTumor, width = 12, height = 12, dpi = 300)

#----- Collation of tabular data

# Get a vector of cell Types to iterate through
celltypes <- unique(spe$cellTypes)

# Set custom colors
custom_colors <- c("EOCRC" = "firebrick2", "LOCRC" = "cyan3")

# Iterate through the non tumor patches to detect the percentage of that cell type in the patch
for(i in celltypes) {
  print(i)
  
  # Calculate the percentage of celltype
  nt_data <- colData(spe) %>% as_tibble() %>%
    group_by(nonTumor_patches, sample_id, Indication) %>%
    summarise(cell_count = sum(cellTypes == i),
              patch_size = n(),
              cell_freq = cell_count / patch_size) %>%
    filter(!is.na(nonTumor_patches)) 
  fileName <- paste(i, "NonTumor_Patches_Tabular_Data.csv", sep = "_")
  
  E <- nt_data[nt_data$Indication == "EOCRC",]
  meanE <- mean(E$cell_freq)
  L <- nt_data[nt_data$Indication == "LOCRC",]
  meanL <- mean(L$cell_freq)
  print(meanE)
  print(meanL)
  
  # Save tabular data
  write.csv(nt_data, file = paste("Outputs/003_Spatial_Assessment", fileName, sep = "/"))
  
  
  # Plot the percentages
  patchPlot2 <- ggplot(nt_data, aes(Indication, cell_freq, fill = Indication)) +
    geom_violin(alpha = 0.3, trim = FALSE, draw_quantiles = TRUE, scale = "width") +
    geom_jitter(aes(color = sample_id), width = 0.1) +
    geom_boxplot(width = 0.4, outliers = FALSE, alpha = 0.3) +
    stat_compare_means(method = "t.test", method.args = list(var.equal = FALSE)) +
    scale_y_continuous(labels = scales::percent) +
    theme_classic() +
    scale_fill_manual(values = custom_colors) +
    labs(y = paste("%", i, sep = " "),
         x = "",
         fill= "Indication",
         color = "ROI") +
    theme(axis.text.x = element_text(face = "bold", size = 20),
          axis.title.y = element_text(face = "bold", size = 24),
          axis.text.y = element_text(size = 20),
          legend.position = "none")
  fileName <- paste(i, "NonTumor_Patches.tiff", sep = "_")
  ggsave(paste("Outputs/003_Spatial_Assessment", fileName, sep = "/"), patchPlot2, width = 8, height = 8, dpi = 300)
  
  # Plot the percentages
  patchPlot3 <- ggplot(nt_data, aes(Indication, cell_freq, fill = Indication)) +
    #geom_violin(alpha = 0.3, trim = FALSE, draw_quantiles = TRUE, scale = "width") +
    #geom_jitter(position = position_jitterdodge(jitter.width = 0.1, dodge.width = 0.25)) +
    geom_boxplot(width = 0.1, outliers = FALSE, alpha = 0.3) +
    stat_compare_means(method = "t.test", method.args = list(var.equal = FALSE)) +
    scale_y_continuous(labels = scales::percent) +
    theme_classic() +
    scale_fill_manual(values = custom_colors) +
    labs(y = paste("%", i, sep = " "),
         x = "",
         fill= "Indication",
         color = "ROI") +
    theme(axis.text.x = element_text(face = "bold", size = 20),
          axis.title.y = element_text(face = "bold", size = 24),
          axis.text.y = element_text(size = 20),
          legend.position = "none") 
  fileName <- paste(i, "AllBlack_NonTumor_Patches.tiff", sep = "_")
  ggsave(paste("Outputs/003_Spatial_Assessment", fileName, sep = "/"), patchPlot3, width = 8, height = 8, dpi = 300)

}

################################################################################

# Save RDS
saveRDS(spe, file = "Data/003_Spatial/Spatial_Analysis_Spe.Rds")





